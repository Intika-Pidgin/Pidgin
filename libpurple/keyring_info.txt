
API
What needs to be done :
	Store a password with/without master password
	Retrieve a password with/without master password
	Forget/delete a password
	Know if a master password can/must be used
	Update a password
	change master password
	close the keyring (open is of course automatic)
	free/clean memory allocated for a password

Several solutions exist, but the one most likely to be used is the following :
 - A NULL master password is passed if no master password is required.
 - A NULL password is passed to remove the account from the keyring
 - The first idea for the fift problem is for libpurple to update the master password, libpurple reads the password, erases it, and stores it back. But considering some keyrings might have a keyring-wide master password, i might be better to have one function to do it all. So this will have it's own function
 - to update a password, a new password is simply written
 - close is a simple function call
 - now, for the delicate part. We need to know what the capabilities for our plugin are. There are several ways for that too, but the one I prefer is the following : a bitmask is stored allong with the structure that contains all the info on the plugin. Using a function, or even worse, return error codes for such a simple task would be pretty ugly imho.

So, now we know what libpurple needs to know about each plugin :
 - read a password
 - store a password
 - change master password
 - capabilities bitmask
 - close the safe
 - free a password's memory	( no need to make that async )

Also, we want to keep track of what plugin is currently being used, and how.
In the preferences, I'll add information on what plugin is being used, as well as weather it's currently using a master password.
This is because some plugins might not know wether a master password is being used or not. (I'm thinking simple crypto stuff that might decrypt as junk if used with the wrong key.)

So, now we know what we need to register a plugin, let's write some defs.

typedef void (*PurpleKeyringReadCallback)(const PurpleAccount * account, int result, gchar * password, gpointer data);
typedef void (*PurpleKeyringSaveCallback)(const PurpleAccount * account, int result, gpointer data);
typedef void (*PurpleKeyringCloseCallback)(int result, gpointer data);	/* async just so we can check for errors */
typedef void (*PurpleKeyringChangeMasterCallback)(int result, gpointer data);

typedef void (*PurpleKeyringRead)(const PurpleAccount * account, gchar * masterpassword, PurpleKeyringReadCallback cb, gpointer data);
typedef void (*PurpleKeyringSave)(const PurpleAccount * account, gchar * masterpassword, PurpleKeyringSaveCallback cb, gpointer data);
typedef void (*PurpleKeyringClose)(gpointer data);
typedef void (*PurpleKeyringChangeMaster)(gchar * oldpassword, gchar * newpassword, PurpleKeyringChangeMasterCallback cb, gpointer data);
typedef void (*PurpleKeyringFree)(gchar * password);

Now, we can write the structure that will contain all this info

typedef struct _PurpleKeyringInfo {
	char * name;
	PurpleKeyringRead read_password;
	PurpleKeyringSave save_password;
	PurpleKeyringClose close_keyring;
	PurpleKeyringFree free_password;
	PurpleKeyringChangeMaster change_master;
	int capabilities;	
	gpointer r1;	/* RESERVED */
	gpointer r2;	/* RESERVED */
	gpointer r3;	/* RESERVED */
} PurpleKeyringInfo;

void purple_plugin_keyring_register(PurpleKeyringInfo * info) /* do we need a callback ? */


Ok, so there's something really cool, all accesses to the passwords are done through this function.

const char *
purple_account_get_password(const PurpleAccount *account)
{
	g_return_val_if_fail(account != NULL, NULL);

	return account->password;
}












stuff to do
	


	/* Read the password */
	child = xmlnode_get_child(node, "password");
	if ((child != NULL) && ((data = xmlnode_get_data(child)) != NULL))
	{
		purple_account_set_remember_password(ret, TRUE);
		purple_account_set_password(ret, data);
		g_free(data);
	}



questions :

 - includes (order and stuff)
 - trannie's mtn is down ?
