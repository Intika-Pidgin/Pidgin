%%
headers
#include <Python.h>
#include "pygobject.h"
#include "gnt.h"
#include "gntbindable.h"
#include "gntwidget.h"
#include "gntbox.h"
#include "gntbutton.h"
#include "gntcheckbox.h"
#include "gntcolors.h"
#include "gntcombobox.h"
#include "gntentry.h"
#include "gntfilesel.h"
#include "gntkeys.h"
#include "gntlabel.h"
#include "gntline.h"
#include "gntmenu.h"
#include "gntmenuitem.h"
#include "gntmenuitemcheck.h"
#include "gntslider.h"
#include "gntstyle.h"
#include "gnttextview.h"
#include "gnttree.h"
#include "gntutils.h"
#include "gntwindow.h"
#include "gntwm.h"
#include "gntws.h"
#include "common.h"
%%
include
 gntbox.override
 gntfilesel.override
 gnttree.override
 gntwidget.override
%%
modulename gnt
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob
	*_get_gtype
%%
define set_flag
static PyObject *
_wrap_set_flag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"flags", NULL};
	PyGObject *widget;
	int flags;

	if (!PyArg_ParseTuple(args, "O!i:gnt.set_flag", &PyGntWidget_Type, &widget,
				&flags)) {
		return NULL;
	}

	GNT_WIDGET_SET_FLAGS(widget->obj, flags);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
define unset_flag
static PyObject *
_wrap_unset_flag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"flags", NULL};
	PyGObject *widget;
	int flags;

	if (!PyArg_ParseTuple(args, "O!i:gnt.unset_flag", &PyGntWidget_Type, &widget,
				&flags)) {
		return NULL;
	}

	GNT_WIDGET_UNSET_FLAGS(widget->obj, flags);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
define screen_size noargs
static PyObject *
_wrap_screen_size(PyObject *self)
{
	PyObject *list = PyList_New(0);

	if (list == NULL)
		return NULL;

	PyList_Append(list, PyInt_FromLong((long)getmaxx(stdscr)));
	PyList_Append(list, PyInt_FromLong((long)getmaxy(stdscr)));

	return list;
}
%%
override gnt_register_action
static GHashTable *actions;



static PyObject *
_wrap_gnt_register_action(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = {"name", "callback", NULL};
	PyGObject *callback;
	GClosure *closure;
	char *name;

	if (!PyArg_ParseTuple(args, "sO:gnt.gnt_register_action", &name, &callback)) {
		return NULL;
	}

	if (!PyCallable_Check(callback)) {
		PyErr_SetString(PyExc_TypeError, "the callback must be callable ... doh!");
		return NULL;
	}

	gnt_register_action(name, callback->obj);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
define register_bindings

static gboolean
pygnt_binding_callback(GntBindable *bindable, GList *list)
{
	PyObject *wrapper = pygobject_new(G_OBJECT(bindable));
	PyObject_CallMethod(wrapper, list->data, "O", Py_None);
	Py_DECREF(wrapper);
	return TRUE;
}

static PyObject *
_wrap_register_bindings(PyObject *self, PyObject *args)
{
	PyTypeObject *class;
	int pos = 0;
	PyObject *key, *value, *gbindings;
	GntBindableClass *bindable;

	if (!PyArg_ParseTuple(args, "O!:gnt.register_bindings",
				&PyType_Type, &class)) {
		/* Make sure it's a GntBindableClass subclass */
		PyErr_SetString(PyExc_TypeError,
				"argument must be a GntBindable subclass");
		return NULL;
	}

	gbindings = PyDict_GetItemString(class->tp_dict, "__gntbindings__");
	if (!gbindings)
		goto end;

	if (!PyDict_Check(gbindings)) {
		PyErr_SetString(PyExc_TypeError,
				"__gntbindings__ attribute not a dict!");
		return NULL;
	}

	bindable = g_type_class_ref(pyg_type_from_object((PyObject *)class));
	while (PyDict_Next(gbindings, &pos, &key, &value)) {
		const char *trigger, *callback, *name;
		GList *list = NULL;

		if (!PyString_Check(key)) {
			PyErr_SetString(PyExc_TypeError,
					"__gntbindings__ keys must be strings");
			g_type_class_unref(bindable);
			return NULL;
		}
		name = PyString_AsString(key);

		if (!PyTuple_Check(value) ||
				!PyArg_ParseTuple(value, "ss", &callback, &trigger)) {
			PyErr_SetString(PyExc_TypeError,
					"__gntbindings__ values must be (callback, trigger) tupples");
			g_type_class_unref(bindable);
			return NULL;
		}

		gnt_bindable_class_register_action(bindable, name, pygnt_binding_callback,
				trigger, g_strdup(callback), NULL);
	}
	if (gbindings)
		PyDict_DelItemString(class->tp_dict, "__gntbindings__");
	g_type_class_unref(bindable);

end:
	Py_INCREF(Py_None);
	return Py_None;
}

