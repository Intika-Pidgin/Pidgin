/**
 * pygnt- Python bindings for the GNT toolkit.
 * Copyright (C) 2007 Sadrul Habib Chowdhury <sadrul@pidgin.im>
 *
 *   gnttree.override: overrides for the tree widget.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02111-1301
 * USA
 */
%%
headers
#include "common.h"
%%
ignore 
gnt_tree_create_row
gnt_tree_create_row_from_list
%%
override gnt_tree_get_selection_text_list noargs
static PyObject *
_wrap_gnt_tree_get_selection_text_list(PyGObject *self)
{
	GList *list = gnt_tree_get_selection_text_list(GNT_TREE(self->obj));
	return create_pyobject_from_string_list(list);
}
%%
override gnt_tree_get_rows noargs
static PyObject *
_wrap_gnt_tree_get_rows(PyGObject *self)
{
	GList *list = gnt_tree_get_rows(GNT_TREE(self->obj));
	PyObject *py_list;
	if (list == NULL) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	if ((py_list = PyList_New(0)) == NULL) {
		return NULL;
	}
	while (list) {
		PyObject *obj = list->data;
		PyList_Append(py_list, obj);
		list = list->next;
	}
	return py_list;
}
%%
override gnt_tree_add_row_after
static PyObject *
_wrap_gnt_tree_add_row_after(PyGObject *self, PyObject *args)
{
	static char *kwlist[] = {"key", "row", "parent", "bigbro", NULL};
	PyObject *py_list;
	gpointer key, parent, bigbro = NULL;
	int len, i;
	GList *list = NULL;
	GntTreeRow *row;
	gboolean insert_last = FALSE;

	if (!PyArg_ParseTuple(args,
				"OOO|O:GntTree.add_row_after",
				&key,
				&py_list,
				&parent,
				&bigbro))
		return NULL;

	len = PySequence_Length(py_list);
	for (i = 0; i < len; i++) {
		PyObject *item = PySequence_GetItem(py_list, i);
		if (!pygobject_check(item, &PyString_Type)) {
			PyErr_SetString(PyExc_TypeError,
					"column_list members must be strings");
			Py_DECREF(item);
			return NULL;
		}
		list = g_list_prepend(list, PyString_AsString(item));
		Py_DECREF(item);
	}

	if (parent == Py_None)
		parent = NULL;
	if (bigbro == Py_None)
		bigbro = NULL;
	else if (bigbro == NULL)
		insert_last = TRUE;

	Py_INCREF((PyObject*)key);

	list = g_list_reverse(list);
	row = gnt_tree_create_row_from_list(GNT_TREE(self->obj), list);
	if (insert_last)
		gnt_tree_add_row_last(GNT_TREE(self->obj),
				key, row, parent);
	else
		gnt_tree_add_row_after(GNT_TREE(self->obj),
				key, row,
				parent, bigbro);
	g_list_free(list);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gnt_tree_get_selection_data noargs
static PyObject *
_wrap_gnt_tree_get_selection_data(PyGObject *self)
{
	PyObject *ret = gnt_tree_get_selection_data(GNT_TREE(self->obj));
	if (!ret)
		ret = Py_None;
	Py_INCREF(ret);
	return ret;
}
%%
override gnt_tree_change_text
static PyObject *
_wrap_gnt_tree_change_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "key", "colno", "text", NULL };
	char *text;
	int colno;
	gpointer key;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Ois:GntTree.change_text", kwlist, &key, &colno, &text))
		return NULL;

	gnt_tree_change_text(GNT_TREE(self->obj), key, colno, text);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gnt_tree_set_row_flags
static PyObject *
_wrap_gnt_tree_set_row_flags(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "key", "flag", NULL };
	int flag;
	gpointer key;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Oi:GntTree.set_row_flags", kwlist, &key, &flag))
		return NULL;

	gnt_tree_set_row_flags(GNT_TREE(self->obj), key, flag);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gnt_tree_remove
static PyObject *
_wrap_gnt_tree_remove(PyGObject *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "key", NULL };
	gpointer key;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:GntTree.remove", kwlist, &key))
		return NULL;

	gnt_tree_remove(GNT_TREE(self->obj), key);

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gnt_tree_set_selected
static PyObject *
_wrap_gnt_tree_set_selected(PyGObject *self, PyObject *args)
{
	gpointer key;
	if (!PyArg_ParseTuple(args, "O:GntTree.set_selected", &key)) {
		return NULL;
	}
	gnt_tree_set_selected(GNT_TREE(self->obj), key);
	Py_INCREF(Py_None);
	return Py_None;
}
%%
override gnt_tree_set_compare_func
static PyObject *
_wrap_gnt_tree_set_compare_func(PyGObject *self, PyObject *args)
{
	static char *kwlist[] = {"compare_func", NULL};
	PyGObject *compare;

	if (!PyArg_ParseTuple(args, "O:GntTree.set_compare_func", &compare)) {
		return NULL;
	}

	if (!PyCallable_Check(compare)) {
		PyErr_SetString(PyExc_TypeError, "the callback must be callable ... doh!");
		return NULL;
	}

	Py_INCREF(compare);
	gnt_tree_set_compare_func(GNT_TREE(self->obj), (GCompareFunc)compare->obj);

	Py_INCREF(Py_None);
	return Py_None;
}

